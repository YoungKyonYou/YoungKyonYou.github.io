I"mZ<p><br /><br /></p>

<p><em><strong>오늘보다 발전된 내일의 나를 위해…</strong></em></p>

<p><br /></p>

<p><br /><br /></p>

<style>
.containercoffee {
  width: 300px;
  height: 280px;
  position: relative;
  top: calc(50% - 140px);
  left: calc(50% - 150px);
}
.coffee-header {
  width: 100%;
  height: 80px;
  position: absolute;
  top: 0;
  left: 0;
  background-color: #ddcfcc;
  border-radius: 10px;
}
.coffee-header__buttons {
  width: 25px;
  height: 25px;
  position: absolute;
  top: 25px;
  background-color: #282323;
  border-radius: 50%;
}
.coffee-header__buttons::after {
  content: "";
  width: 8px;
  height: 8px;
  position: absolute;
  bottom: -8px;
  left: calc(50% - 4px);
  background-color: #615e5e;
}
.coffee-header__button-one {
  left: 15px;
}
.coffee-header__button-two {
  left: 50px;
}
.coffee-header__display {
  width: 50px;
  height: 50px;
  position: absolute;
  top: calc(50% - 25px);
  left: calc(50% - 25px);
  border-radius: 50%;
  background-color: #9acfc5;
  border: 5px solid #43beae;
  box-sizing: border-box;
}
.coffee-header__details {
  width: 8px;
  height: 20px;
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: #9b9091;
  box-shadow: -12px 0 0 #9b9091, -24px 0 0 #9b9091;
}
.coffee-medium {
  width: 90%;
  height: 160px;
  position: absolute;
  top: 80px;
  left: calc(50% - 45%);
  background-color: #bcb0af;
}
.coffee-medium:before {
  content: "";
  width: 90%;
  height: 100px;
  background-color: #776f6e;
  position: absolute;
  bottom: 0;
  left: calc(50% - 45%);
  border-radius: 20px 20px 0 0;
}
.coffe-medium__exit {
  width: 60px;
  height: 20px;
  position: absolute;
  top: 0;
  left: calc(50% - 30px);
  background-color: #231f20;
}
.coffe-medium__exit::before {
  content: "";
  width: 50px;
  height: 20px;
  border-radius: 0 0 50% 50%;
  position: absolute;
  bottom: -20px;
  left: calc(50% - 25px);
  background-color: #231f20;
}
.coffe-medium__exit::after {
  content: "";
  width: 10px;
  height: 10px;
  position: absolute;
  bottom: -30px;
  left: calc(50% - 5px);
  background-color: #231f20;
}
.coffee-medium__arm {
  width: 70px;
  height: 20px;
  position: absolute;
  top: 15px;
  right: 25px;
  background-color: #231f20;
}
.coffee-medium__arm::before {
  content: "";
  width: 15px;
  height: 5px;
  position: absolute;
  top: 7px;
  left: -15px;
  background-color: #9e9495;
}
.coffee-medium__cup {
  width: 80px;
  height: 47px;
  position: absolute;
  bottom: 0;
  left: calc(50% - 40px);
  background-color: #FFF;
  border-radius: 0 0 70px 70px / 0 0 110px 110px;
}
.coffee-medium__cup::after {
  content: "";
  width: 20px;
  height: 20px;
  position: absolute;
  top: 6px;
  right: -13px;
  border: 5px solid #FFF;
  border-radius: 50%;
}
@keyframes liquid {
  0% {
    height: 0px;  
    opacity: 1;
  }
  5% {
    height: 0px;  
    opacity: 1;
  }
  20% {
    height: 62px;  
    opacity: 1;
  }
  95% {
    height: 62px;
    opacity: 1;
  }
  100% {
    height: 62px;
    opacity: 0;
  }
}
.coffee-medium__liquid {
  width: 6px;
  height: 63px;
  opacity: 0;
  position: absolute;
  top: 50px;
  left: calc(50% - 3px);
  background-color: #74372b;
  animation: liquid 4s 4s linear infinite;
}
.coffee-medium__smoke {
  width: 8px;
  height: 20px;
  position: absolute;  
  border-radius: 5px;
  background-color: #b3aeae;
}
@keyframes smokeOne {
  0% {
    bottom: 20px;
    opacity: 0;
  }
  40% {
    bottom: 50px;
    opacity: .5;
  }
  80% {
    bottom: 80px;
    opacity: .3;
  }
  100% {
    bottom: 80px;
    opacity: 0;
  }
}
@keyframes smokeTwo {
  0% {
    bottom: 40px;
    opacity: 0;
  }
  40% {
    bottom: 70px;
    opacity: .5;
  }
  80% {
    bottom: 80px;
    opacity: .3;
  }
  100% {
    bottom: 80px;
    opacity: 0;
  }
}
.coffee-medium__smoke-one {
  opacity: 0;
  bottom: 50px;
  left: 102px;
  animation: smokeOne 3s 4s linear infinite;
}
.coffee-medium__smoke-two {
  opacity: 0;
  bottom: 70px;
  left: 118px;
  animation: smokeTwo 3s 5s linear infinite;
}
.coffee-medium__smoke-three {
  opacity: 0;
  bottom: 65px;
  right: 118px;
  animation: smokeTwo 3s 6s linear infinite;
}
.coffee-medium__smoke-for {
  opacity: 0;
  bottom: 50px;
  right: 102px;
  animation: smokeOne 3s 5s linear infinite;
}
.coffee-footer {
  width: 95%;
  height: 15px;
  position: absolute;
  bottom: 25px;
  left: calc(50% - 47.5%);
  background-color: #41bdad;
  border-radius: 10px;
}
.coffee-footer::after {
  content: "";
  width: 106%;
  height: 26px;
  position: absolute;
  bottom: -25px;
  left: -8px;
  background-color: #000;
}
</style>

<div class="containercoffee">
    <div class="coffee-header">
      <div class="coffee-header__buttons coffee-header__button-one"></div>
      <div class="coffee-header__buttons coffee-header__button-two"></div>
      <div class="coffee-header__display"></div>
      <div class="coffee-header__details"></div>
    </div>
    <div class="coffee-medium">
      <div class="coffe-medium__exit"></div>
      <div class="coffee-medium__arm"></div>
      <div class="coffee-medium__liquid"></div>
      <div class="coffee-medium__smoke coffee-medium__smoke-one"></div>
      <div class="coffee-medium__smoke coffee-medium__smoke-two"></div>
      <div class="coffee-medium__smoke coffee-medium__smoke-three"></div>
      <div class="coffee-medium__smoke coffee-medium__smoke-for"></div>
      <div class="coffee-medium__cup"></div>
    </div>
    <div class="coffee-footer"></div>
</div>

<p><br /><br /><br /><br /><br /><br /><br /><br /></p>

<h1 id="design-pattern-wrapper-pattern"><center>Design Pattern-Wrapper Pattern</center></h1>

<p><br /></p>

<p><em>해당 내용은 POCU 아카데미 COMP_2500에서 배운 내용을 공부하기 위해 작성된 글입니다</em></p>

<p><br /></p>

<h3 id="wrapper-pattern">Wrapper Pattern</h3>

<ul>
  <li>주로 업계에서는 래퍼(wrapper) 패턴이라 함</li>
  <li>GoF 책에서는 어댑터(adapter) 패턴이란 이름을 사용</li>
  <li>어떤 클래스의 메서드 시그내처가 맘에 안 들 때 다른 걸로 바꾸는 방법</li>
  <li>단, 그 클래스의 메서드 시그내처를 직접 변경하지 않음
    <ul>
      <li>그 클래스의 소스코드가 없을 수도 있음</li>
      <li>그 클래스에 의존하는 다른 코드가 있을 수도 있음</li>
    </ul>
  </li>
  <li>그 대신 새로운 클래스를 만들어 기존 클래스를 감쌈</li>
</ul>

<p><br /></p>

<p><img src="/images/Interview/post3/2021-12-15-22-25-40.png?style=centerme" alt="" /></p>

<p><br /></p>

<p>Wrapper란 포장지를 의미한다. A 클래스의 어떤 getA()라는 메서드 시그니처가 있는데 마음에 안들어서 바꾼다고 해보자. 그러면 클래스 B를 만들고 클래스 B안에 클래스 A를 포함하는 것이다. 정확히 말하면 클래스 A로부터 만든 개체를 포함하는 것이다. 그리고 앞으로 클래스 B에 있는 getB() 메서드를 호출할 건데 이게 알아서 A의 getA()를 호출해주는 것이다. 즉 내가 호출할 때는 B만 사용하고 내부적으로는 getA()를 어떻게서든 사용하는 것이다. 그래서 기존의 클래스를 감싼다고 해서 <strong>Wrapper Pattern</strong> 이라고 부른다.</p>

<p><br /></p>

<p><img src="/images/Interview/post3/2021-12-15-22-29-37.png?style=centerme" alt="" /></p>

<p><br /></p>

<p>위의 사진과 같이 어댑터와 같이 이해할 수도 있다. 원래 A의 getA()라는 메서드가 있었으면 A를 그대로 사용하지 않고 앞에 B라는 어댑터를 꽂는 거이다. 그럼 A에 있는 뭔가에 어댑터를 꽂았으니까 바로 접근할 수 있는 방법이 없다. 그래서 B에서 어떻게든 접속을 해서 사용을 하라는 것이다.</p>

<p><br /></p>

<h4 id="메서드-시그니처를-바꾸려는-다양한-이유">메서드 시그니처를 바꾸려는 다양한 이유</h4>

<ul>
  <li>추후 외부 라이브러리를 바꿀 때 클라이언트 코드를 변경하지 않기 위해</li>
  <li>그냥 사용 중인 메서드가 코딩 표준에 맞지 않아서</li>
  <li>기존 클래스에 없는 기능을 추가하기 위해</li>
  <li>확장된 용도: 내부 개체를 클라이언트에게 노출시키지 않기 위해
    <ul>
      <li>DTO(data transfer object) 만들기</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>코드로 예를 보자. 윈도우에서 사용 가능한 3D 그래픽 API는 대표적으로 두 개가 있다.</p>

<ul>
  <li><strong>Microsoft DirectX</strong></li>
  <li><strong>OpenGL</strong></li>
</ul>

<p><br /></p>

<p>두 API 모두 컴퓨터에 설치된 그래픽 카드를 사용한다. 따라서 두 API에서 지원하는 기능이 매우 비슷하다. 아래와 같은 두 클래스가 있다고 하자.</p>

<p><br /></p>

<p><img src="/images/Interview/post3/2021-12-15-22-46-27.png?style=centerme" alt="" /></p>

<p><br /></p>

<p>clear()와 clearScreen() 메서드는 둘 다 화면을 어떤 색상으로 지우는 메서드이다. 다른 점은 메서드 이름과 r, g, b, a 매개변수의 형과 유효한 범위이다. <strong>float</strong>은 <strong>[0.0. 1.0]</strong>이고 <strong>int</strong>는 <strong>[0, 255]</strong>이다.</p>

<p><br /></p>

<p>원래 프로그램에서 OpenGL을 사용했다면(즉, 내가 클라이언트) 내 소스파일 곳곳에 이런 코드가 있을 것이다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="o">.</span><span class="na">graphics</span><span class="o">.</span><span class="na">clearScreen</span><span class="o">(</span><span class="mi">1</span><span class="o">.</span><span class="na">f</span><span class="o">,</span> <span class="mi">0</span><span class="o">.</span><span class="na">f</span><span class="o">,</span> <span class="mi">0</span><span class="o">.</span><span class="na">f</span><span class="o">,</span> <span class="mi">0</span><span class="o">.</span><span class="na">f</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<p>그리고 추후 DirectX로 바꾸기로 결정하면 위의 코드를 찾아 고쳐야 한다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="o">.</span><span class="na">graphics</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">255</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<p>즉 수정할 코드가 많을수록 실수할 가능성이 높아진다.</p>

<p><span style="color:orange; font-weight:bold">이럴 때 래퍼 클래스를 만들어 사용하면 한 곳에서만 바꾸면 된다.</span></p>

<p><br /></p>

<p><strong>Graphics Wrapper Class</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Graphics</span><span class="o">{</span>
  <span class="kd">private</span> <span class="nc">OpenGL</span> <span class="n">gl</span><span class="o">;</span>

  <span class="o">...</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">(</span><span class="kt">float</span> <span class="n">r</span><span class="o">,</span> <span class="kt">float</span> <span class="n">g</span><span class="o">,</span> <span class="kt">float</span> <span class="n">b</span><span class="o">,</span> <span class="kt">float</span> <span class="n">a</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">gl</span><span class="o">.</span><span class="na">clearScreen</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p>내부에 OpenGL 개체를 들고 있고 Graphics 메서드는 OpenGL의 메서드를 호출한다.</p>

<p><br /></p>

<p><strong>Main Class</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Graphics</span> <span class="n">graphics</span><span class="o">;</span>
<span class="k">this</span><span class="o">.</span><span class="na">graphics</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="mi">0</span><span class="o">.</span><span class="na">f</span><span class="o">,</span> <span class="mi">0</span><span class="o">.</span><span class="na">f</span><span class="o">,</span> <span class="mi">0</span><span class="o">.</span><span class="na">f</span><span class="o">,</span> <span class="mi">1</span><span class="o">.</span><span class="na">f</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<p>Graphics 개체만 만들고 속에 OpenGL 개체가 들어있다. Graphics 개체의 메서드만 호출한다. 이제 여기서 OpenGL 대신 DirectX를 사용하려면 어떻게 해야 할까? <strong>Graphics</strong> 클래스 안에서 OpenGL 개체를 DirectX 개체로 변경하면 된다.</p>

<p><strong>Graphics Class</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Graphics</span><span class="o">{</span>
  <span class="kd">private</span> <span class="nc">OpenGL</span> <span class="n">gl</span><span class="o">;</span>

  <span class="o">...</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">(</span><span class="kt">float</span> <span class="n">r</span><span class="o">,</span> <span class="kt">float</span> <span class="n">g</span><span class="o">,</span> <span class="kt">float</span> <span class="n">b</span><span class="o">,</span> <span class="kt">float</span> <span class="n">a</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">gl</span><span class="o">.</span><span class="na">clearScreen</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p>위 코드를 아래와 같이 바꾼다.</p>

<p><br /></p>

<p><strong>Graphics Class</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Graphics</span><span class="o">{</span>
  <span class="kd">private</span> <span class="nc">DirectX</span> <span class="n">dx</span><span class="o">;</span>

  <span class="o">...</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">(</span><span class="kt">float</span> <span class="n">r</span><span class="o">,</span> <span class="kt">float</span> <span class="n">g</span><span class="o">,</span> <span class="kt">float</span> <span class="n">b</span><span class="o">,</span> <span class="kt">float</span> <span class="n">a</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">dx</span><span class="o">.</span><span class="na">clear</span><span class="o">((</span><span class="kt">int</span><span class="o">)(</span><span class="n">r</span><span class="o">*</span><span class="mi">255</span><span class="o">),(</span><span class="kt">int</span><span class="o">)(</span><span class="n">g</span><span class="o">*</span><span class="mi">255</span><span class="o">),(</span><span class="kt">int</span><span class="o">)(</span><span class="n">b</span><span class="o">*</span><span class="mi">255</span><span class="o">),</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">a</span><span class="o">*</span><span class="mi">255</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p>즉, <strong>Graphics</strong> 메서드들이 DirectX 메서드를 호출하게 변경한다.</p>

<p><br /></p>

<p>그리고 추가적으로 살펴볼 것이 DTO이다. 엄밀히 말하면 어댑터 패턴은 아니지만 궁극적인 목표가 같은 DTO 개념에 대해서 살펴본다. 어댑터 패턴은 타 클래스의 메서드 시그내처를 내 필요에 맞게 바꾸는 것이다. DTO는 타 클래스의 데이터를 내 필요에 맞게 바꾸는 것이다.</p>

<p><br /></p>

<p>이제 DTO 변환하기의 간단한 예를 살펴보자. 시스템 규모가 크면 종종 이런 문제들을 겪는다.</p>

<p><br /></p>

<p><img src="/images/Interview/post3/2021-12-15-23-16-12.png?style=centerme" alt="" /></p>

<p><br /></p>

<p>DB에 저장된 데이터를 읽어와서 웹페이지에 보여준다고 가정했을 때 PersonEntitiy의 모든 정보를 반환하면 필요 이상의 데이터를 반환하게 되는 것이다. 따라서 정말 클라이언트가 필요로 하는 정보만 반환하는 게 더 좋다 이때 데이터 전송에만 사용하는 개체를 데이터 전공 개체(DTO)라 한다.</p>

<p><br /></p>

<p><img src="/images/Interview/post3/2021-12-15-23-17-56.png?style=centerme" alt="" /></p>

<p><br /></p>

<p><strong>PersonEntity Class</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">PersonEntity</span><span class="o">{</span>
  <span class="kd">public</span> <span class="no">UUID</span> <span class="n">id</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="n">fullName</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="n">passwordHash</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="n">phoneNumber</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="n">balance</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nc">Date</span> <span class="n">createDateTime</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nc">Date</span> <span class="n">modifiedDateTime</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nc">PeronDto</span> <span class="nf">toDto</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">PersonDto</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">fullName</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">email</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">createdDateTime</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p>위와 같이 구성하게 되면 웹에서 필요한 데이터만 DTO로 변환해 전달해줄 수 있다. 즉 필요없는 정보를 안 보내게 됨으로 메모리를 아끼고 보안성을 갖출 수 있는 것이다.</p>

<hr />

<h3 id="적응자adapter-패턴">적응자(Adapter) 패턴</h3>

<p><br /></p>

<p>적응자 패턴은 다른 이름으로 래퍼(Wrapper)라고 불리우는 패턴이다.</p>

<p><strong>클래스의 인터페이스를 사용자가 원하는 형태로 변환(적응) 시킨다.</strong></p>

<p>이렇게 변환(적응)을 통해서 일치하지 않는 인터페이스를 갖는 클래스들이 함께 동작할 수 있도록 한다.</p>

<p><br /></p>

<h3 id="시나리오"><span style="color:#2ECC40; font-weight:bold">시나리오</span></h3>

<p><br /></p>

<p>그림 편집기가 있다.</p>

<p>그림판의 주요한 추상적 개념은 그래픽 객체들이다.</p>

<p>이런 공통 그래픽 요소에 대한 인터페이스는 추상 클래스인 Shape에 정의되어 있다.</p>

<p>그리고 각 그래픽 요소인 선과 다각형은 각각 <strong>LineShape, PolygonShape</strong>과 같은 클래스로 개발해야 한다.</p>

<p><br /></p>

<p>위와 같이 간단한 도형도 있겠지만 <strong>TextShape</strong>는 텍스트 처리시 <strong>버퍼 관리</strong>와 같이 다른 그래픽 요소에 비해 <strong>특별하게 고려해야할 점</strong>이 있을 수 있다.</p>

<p><br /></p>

<p>이때 재사용할 수 있는 라이브러리나 자원이 없을까 조사를 하게 된다.</p>

<p>다행히 <strong>사용자 인터페이스 툴킷</strong>에서 복잡한 <strong>TextView</strong>를 처리하는 클래스를 제공하고 있다고 <strong>가정</strong>하자.</p>

<p>당연히 재사용하는 것이 바람직하긴 하지만 <strong>TextView</strong>는 <strong>Shape</strong>를 고려해서 설계한 것이 아니라서 곧바로 <strong>TextShape</strong> 클래스로 대체하여 사용할 수 없다.</p>

<p><br /></p>

<h3 id="적응자-패턴의-구조"><span style="color:#2ECC40; font-weight:bold">적응자 패턴의 구조</span></h3>

<p><br /></p>

<p>적응자 패턴에는 2 가지 구현 방식이 있다.</p>

<ul>
  <li>TextShape(Adapter)가 Shape의 인터페이스와 TextView의 구현을 모두 상속</li>
  <li>TextShape(Adapter)가 TextView의 인스턴스를 포함하고, TextView의 인터페이스를 사용</li>
</ul>

<p><br /></p>

<p>아래 다이어그램은 위의 방법 중 <strong>인스턴스를 포함한 방식</strong>으로 적응자 패턴을 구현한 다이어그램이다.</p>

<p><br /></p>

<p><img src="/images/Interview/post16/2021-12-29-23-27-50.png?style=centerme" alt="" /></p>

<p><br /></p>

<p>위에서 TextShape은 TextView 클래스에 정의된 인터페이스를 바꾸어 Shape 클래스에 정의된 인터페이스와 잘 부합되게 한다.</p>

<p>이로써 TextView 클래스를 TextShape 적응자를 통해 재사용할 수 있게 되었다.</p>

<p><br /></p>

<p>적응자 패턴의 참여자는 아래와 같다.</p>

<p><br /></p>

<p><span style="color:#3D9970; font-weight:bold">Client(DrawingEditor):</span> <strong>Target</strong> 인터페이스를 만족하는 객체와 동작할 대상</p>
:ET