I"l<p><br /><br /></p>

<p><strong><em>해당 내용은 책 &lt;컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커&gt;에 나오는 내용이며 이는 개인적으로 공부하기 위해서 게시하는 글임을 알립니다.</em></strong></p>

<p><br /><br />
<em><strong>커피 중독자되는 중…</strong></em>
<br />
(Press the Button)</p>

<p><br /><br /></p>

<style>
.containercoffee {
  width: 300px;
  height: 280px;
  position: relative;
  top: calc(50% - 140px);
  left: calc(50% - 150px);
}
.coffee-header {
  width: 100%;
  height: 80px;
  position: absolute;
  top: 0;
  left: 0;
  background-color: #ddcfcc;
  border-radius: 10px;
}
.coffee-header__buttons {
  width: 25px;
  height: 25px;
  position: absolute;
  top: 25px;
  background-color: #282323;
  border-radius: 50%;
}
.coffee-header__buttons::after {
  content: "";
  width: 8px;
  height: 8px;
  position: absolute;
  bottom: -8px;
  left: calc(50% - 4px);
  background-color: #615e5e;
}
.coffee-header__button-one {
  left: 15px;
}
.coffee-header__button-two {
  left: 50px;
}
.coffee-header__display {
  width: 50px;
  height: 50px;
  position: absolute;
  top: calc(50% - 25px);
  left: calc(50% - 25px);
  border-radius: 50%;
  background-color: #9acfc5;
  border: 5px solid #43beae;
  box-sizing: border-box;
}
.coffee-header__details {
  width: 8px;
  height: 20px;
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: #9b9091;
  box-shadow: -12px 0 0 #9b9091, -24px 0 0 #9b9091;
}
.coffee-medium {
  width: 90%;
  height: 160px;
  position: absolute;
  top: 80px;
  left: calc(50% - 45%);
  background-color: #bcb0af;
}
.coffee-medium:before {
  content: "";
  width: 90%;
  height: 100px;
  background-color: #776f6e;
  position: absolute;
  bottom: 0;
  left: calc(50% - 45%);
  border-radius: 20px 20px 0 0;
}
.coffe-medium__exit {
  width: 60px;
  height: 20px;
  position: absolute;
  top: 0;
  left: calc(50% - 30px);
  background-color: #231f20;
}
.coffe-medium__exit::before {
  content: "";
  width: 50px;
  height: 20px;
  border-radius: 0 0 50% 50%;
  position: absolute;
  bottom: -20px;
  left: calc(50% - 25px);
  background-color: #231f20;
}
.coffe-medium__exit::after {
  content: "";
  width: 10px;
  height: 10px;
  position: absolute;
  bottom: -30px;
  left: calc(50% - 5px);
  background-color: #231f20;
}
.coffee-medium__arm {
  width: 70px;
  height: 20px;
  position: absolute;
  top: 15px;
  right: 25px;
  background-color: #231f20;
}
.coffee-medium__arm::before {
  content: "";
  width: 15px;
  height: 5px;
  position: absolute;
  top: 7px;
  left: -15px;
  background-color: #9e9495;
}
.coffee-medium__cup {
  width: 80px;
  height: 47px;
  position: absolute;
  bottom: 0;
  left: calc(50% - 40px);
  background-color: #FFF;
  border-radius: 0 0 70px 70px / 0 0 110px 110px;
}
.coffee-medium__cup::after {
  content: "";
  width: 20px;
  height: 20px;
  position: absolute;
  top: 6px;
  right: -13px;
  border: 5px solid #FFF;
  border-radius: 50%;
}
@keyframes liquid {
  0% {
    height: 0px;  
    opacity: 1;
  }
  5% {
    height: 0px;  
    opacity: 1;
  }
  20% {
    height: 62px;  
    opacity: 1;
  }
  95% {
    height: 62px;
    opacity: 1;
  }
  100% {
    height: 62px;
    opacity: 0;
  }
}
.coffee-medium__liquid {
  width: 6px;
  height: 63px;
  opacity: 0;
  position: absolute;
  top: 50px;
  left: calc(50% - 3px);
  background-color: #74372b;
  animation: liquid 4s 4s linear infinite;
}
.coffee-medium__smoke {
  width: 8px;
  height: 20px;
  position: absolute;  
  border-radius: 5px;
  background-color: #b3aeae;
}
@keyframes smokeOne {
  0% {
    bottom: 20px;
    opacity: 0;
  }
  40% {
    bottom: 50px;
    opacity: .5;
  }
  80% {
    bottom: 80px;
    opacity: .3;
  }
  100% {
    bottom: 80px;
    opacity: 0;
  }
}
@keyframes smokeTwo {
  0% {
    bottom: 40px;
    opacity: 0;
  }
  40% {
    bottom: 70px;
    opacity: .5;
  }
  80% {
    bottom: 80px;
    opacity: .3;
  }
  100% {
    bottom: 80px;
    opacity: 0;
  }
}
.coffee-medium__smoke-one {
  opacity: 0;
  bottom: 50px;
  left: 102px;
  animation: smokeOne 3s 4s linear infinite;
}
.coffee-medium__smoke-two {
  opacity: 0;
  bottom: 70px;
  left: 118px;
  animation: smokeTwo 3s 5s linear infinite;
}
.coffee-medium__smoke-three {
  opacity: 0;
  bottom: 65px;
  right: 118px;
  animation: smokeTwo 3s 6s linear infinite;
}
.coffee-medium__smoke-for {
  opacity: 0;
  bottom: 50px;
  right: 102px;
  animation: smokeOne 3s 5s linear infinite;
}
.coffee-footer {
  width: 95%;
  height: 15px;
  position: absolute;
  bottom: 25px;
  left: calc(50% - 47.5%);
  background-color: #41bdad;
  border-radius: 10px;
}
.coffee-footer::after {
  content: "";
  width: 106%;
  height: 26px;
  position: absolute;
  bottom: -25px;
  left: -8px;
  background-color: #000;
}
</style>

<div class="containercoffee">
    <div class="coffee-header">
      <div class="coffee-header__buttons coffee-header__button-one"></div>
      <div class="coffee-header__buttons coffee-header__button-two"></div>
      <div class="coffee-header__display"></div>
      <div class="coffee-header__details"></div>
    </div>
    <div class="coffee-medium">
      <div class="coffe-medium__exit"></div>
      <div class="coffee-medium__arm"></div>
      <div class="coffee-medium__liquid"></div>
      <div class="coffee-medium__smoke coffee-medium__smoke-one"></div>
      <div class="coffee-medium__smoke coffee-medium__smoke-two"></div>
      <div class="coffee-medium__smoke coffee-medium__smoke-three"></div>
      <div class="coffee-medium__smoke coffee-medium__smoke-for"></div>
      <div class="coffee-medium__cup"></div>
    </div>
    <div class="coffee-footer"></div>
</div>

<p><br /><br /><br /><br /><br /><br /><br /><br /></p>

<h1 id="온프레미스에서-로드밸런서를-제공하는-metallb"><center>온프레미스에서 로드밸런서를 제공하는 MetalLB</center></h1>

<p><br /></p>

<p>노드포트는 굉장히 심플하다. 현실적으로 노드포트가 서비스하는 방식은 굉장히 효율이 떨어진다. 아래 사진을 참고해보자.</p>

<ol>
  <li>
    <p>사용자가 워크 노드에 있는 포트에 먼저 접속을 한다. (순서도 1번 참고)</p>
  </li>
  <li>
    <p>접속을 한 이후에 해당 워크 노드가 서비스로 이를 바인딩 해준다 (순서도 2번 참고)</p>
  </li>
  <li>
    <p>서비스가 현재 있는 상태를 봐 가면서 노드에 연결을 해주게 된다.(순서도 3번 참고)</p>
  </li>
</ol>

<p><br /></p>

<p>즉 비효율적으로 사용자가 <span style="color:orange; font-weight:bold">서비스</span>에 접근해서 <span style="color:orange; font-weight:bold">서비스</span>가 바로 <span style="color:orange; font-weight:bold">파드</span>에 접근하는 게 아니라 사용자가 워크 노드 포트에 꼭 접속을 해서 이를 <span style="color:orange;font-weight:bold">서비스</span>로 보내준 다음에 <span style="color:orange; font-weight:bold">서비스</span>가 파드에 보내주는 구조이기 때문에 효율성이 떨어진다. 그리고 다른 문제는 워크 노드가 죽었다면 접속해야 되는 사용자에 있는 IP가 변경이 된다 그렇다면 이것은 대표 IP라는 컨셉이 떨어지기 때문에 사용자가 IP를 알아야된다. 이부분은 사실 제대로 서비스를 하기에는 부족한 부분이 있다. 그래서 프로덕션에서는 노드포트를 이용해서 서비스를 하진 않고 테스트용으로 노드포트를 사용한다.</p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-14-45-41.png" alt="" /></p>

<p><br /></p>

<p>그래서 쿠버네티스에서는 <strong>로드 밸런서(LoadBalancer)</strong>라는 서비스 타입을 제공해 간단한 구조로 파드를 외부에 노출하고 부하를 분산한다. 아래 사진을 참고하여 위의 사진과 구조를 비교해보자.</p>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-15-04-07.png" alt="" /></p>

<p><br /></p>

<p>노드포트의 구조와 비교해봤을 때 매우 단순하다. 이는 클라우드 환경에서 동작하는 방식이다. 사용자가 클라우드 노드밸러스 타입에 접근한지는 모른다 즉 보여지지 않지만 거기에 접근해서 바로 <strong>Load Balancer 서비스의 External IP</strong>(그림의 노란색 부분)에 접근한 이후에 바로 내부에 있는 파드로 연결해주게 된다. 굉장히 간결하게 동작을 한다.</p>

<p><br /></p>

<p>온프레미스에서 로드밸러서를 사용하려면 로드밸러서를 <strong>이미 구현해 둔 서비스업체</strong>의 도움을 받아 <strong>쿠버네티스 클러스터 외부</strong>에 구현해야 한다.</p>

<p><br /></p>

<p>온프레미스에서 로드밸런서를 사용하려면 내부에 로드밸런서 서비스를 받아주는 구성이 필요한데, 이를 지원하는 것이 <strong>MetalLB</strong>이다. <strong>MetalLB</strong>는 베어메탈(bare metal, 운영체제가 설치되지 않은 하드웨어)로 구성된 쿠버네티스에서도 로드밸런서를 사용할 수 있게 고안된 프로젝트이다. <strong>MetalLB</strong>는 특별한 네트워크 설정이나 구성이 있는 것이 아니라 기존의 <strong>L2 네트워크(ARP/NDP)</strong>와 <strong>L3 네트워크(BGP)</strong>로 로드밸런서를 구현한다. 그러므로 네트워크를 새로 배워야 할 부담이 없으며 연동하기도 매우 쉽다.</p>

<p><br /></p>

<p>온프레미스 환경의 로드밸런서의 구조를 아래 사진으로 본다.</p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-15-27-31.png" alt="" /></p>

<p><br /></p>

<p>MetalLB 서비스는 위와 같이 동작하는데 기존의 봤던 클라우드 로드 밸런스와 굉장히 유사하다. 사용자가 서비스에 접근을 해서(순서도 1번) 서비스가 파드에 그대로 포워딩(순서도 2번)해주는 구조이다. 점선으로 표시한 부분은 MetalLB 컨트롤러와 MetalLB 스피커에서 자동으로 관리해주는 부분이다. 이것들이 자동으로 관리해줘서 로드 밸런스의 서비스가 파드에 접속할 수 있게 되는 것이다.</p>

<p><br /></p>

<link href="http://fonts.googleapis.com/earlyaccess/hanna.css" rel="stylesheet" />

<div style="background: #eee;
  box-shadow: 0 8px 8px -4px lightblue; font-family: 'Hanna', sans-serif;; padding: 40px;">

<span style="color:#85144b; font-weight:bold">ARP(Address Resolution Protocol)</span>: 아이피주소에서 MAC 주소로 변환되는 과정을 거칠 때 사용하는 프로토콜</div>

<div style="background: #eee;
  box-shadow: 0 8px 8px -4px lightblue; font-family: 'Hanna', sans-serif;; padding: 40px;">

<span style="color:#85144b; font-weight:bold">MAC 주소</span>: IP 주소와 MAC 주소가 있어야지만 서로 통신이 가능하다. 이는 TCP/IP와 OSI 7 Layer라는 통신표준에서 설계되어 있는대로 통신이 진행되기 때문이다. IP 주소는 Layer 3 네트워크에서 사용되고 MAC 주소는 Layer 2 데이터링크에서 사용되는 주소이다. 통신을 하기 위한 모든 랜카드에는 고유한 MAC 주소가 존재한다. 이는 세상에 딱 하나만 존재하는 주소다. 그렇기 때문에 MAC 주소를 알면 통신하고 싶은 장비를 찾을 수 있다. 처음 통신이 MAC 주소되는 것은 아니다. 처음에는 IP 주소로 시도된다. 예를 들어 내 컴퓨터 IP 주소가 192.168.0.100이라고 하다면 나랑 통신하는 상대방은 192.168.0.0 네트워크 대역까지 찾아온다. 그 뒤 192.168.0.100을 찾고 내 컴퓨터 맥 주소로 목적지를 변환한 뒤 최종적으로 나와 통신을 할 수 있게 된다. 즉 MAC 주소는 Media Access Control의 줄임말로 통신할 하드웨어 장비를 식별할 수 있는 고유 주소이다. </div>

<div style="background: #eee;
  box-shadow: 0 8px 8px -4px lightblue; font-family: 'Hanna', sans-serif;; padding: 40px;">

<span style="color:#85144b; font-weight:bold">BGP(Boarder Gateway Protocol)</span>: AS와 AS 사이에서 이루어지는 라우팅 프로토콜이다.</div>

<div style="background: #eee;
  box-shadow: 0 8px 8px -4px lightblue; font-family: 'Hanna', sans-serif;; padding: 40px;">

<span style="color:#85144b; font-weight:bold">NDP(Neighbor Discovery Protocol)</span>: IPv6의 핵심적인 프로토콜로써, 로컬 네트워크 내 이웃 노드, 주소 등의 정보를 탐색하기 위한 프로토콜</div>

<div style="background: #eee;
  box-shadow: 0 8px 8px -4px lightblue; font-family: 'Hanna', sans-serif;; padding: 40px;">

<span style="color:#85144b; font-weight:bold">AS(Autonomous System)</span>: 동일한 라우팅 정책으로 하나의 관리자에 의하여 운영되는 네트워크(즉 한 회사나 단체에서 관리하는 라우터 집단이다.) 네트워크의 크기가 커지고, 라우팅 정보가 방대해짐에 따라서 하나의 라우팅 프로토콜로 전체 네트워크를 관리할 수 없게 되었다. 네트워크 관리 범위를 계층화하고, 라우팅 정보를 보다 효율적으로 관리하기 위해 자율 시스템이 도입되었다. 라우터는 모든 네트워크의 도달 정보를 가지지 않고 자율시스템(AS) 내의 도달 정보만을 가지면 된다.</div>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-12-51-11.png" alt="" /></p>

<p><br /></p>

<p>아래 사진은 특정 레이어에 따른 로드밸런싱을 하는 방법 들이다.</p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-14-04-21.png" alt="" /></p>

<p><br /></p>

<p>이 책에서는 MetalLB의 L2 네트워크로 로드밸런서를 구현한다.</p>

<p>MetalLB 컨트롤러는 작동 방식(Protocol, 프로토콜)을 정의하고 EXTERNAL-IP를 부여해 관리한다. MetalLB 스피커(speaker)는 정해진 작동 방식(L2/ARP, L3/BGP)에 따라 경로를 만들 수 있도록 네트워크 정보를 광고하고 수집해 각 파드의 경로를 제공한다. 이때 L2는 스피커 중에서 리더를 선출해 경로 제공을 총괄한다.</p>

<p><br /></p>

<ol>
  <li>디플로이먼트를 이용해 2종류(lb-hname-pods, lb-ip-pods)의 파드를 생성한다. 그리고 scale 명령으로 파드를 3개로 늘려 노드당 1개씩 파드가 배포되게 한다.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create deployment lb-hname-pods <span class="nt">--image</span><span class="o">=</span>sysnet4admin/echo-hname
kubectl scale deployment lb-hname-pods <span class="nt">--replicas</span><span class="o">=</span>3
kubectl create deployment lb-ip-pods <span class="nt">--image</span><span class="o">=</span>sysnet4admin/echo-ip
kubectl scale deloyment lb-ip-pods <span class="nt">--replicas</span><span class="o">=</span>3
</code></pre></div></div>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-16-32.png" alt="" /></p>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-17-03.png" alt="" /></p>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-20-50.png" alt="" /></p>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-21-37.png" alt="" /></p>

<p><br /></p>

<ol>
  <li>2종류의 파드가 3개씩 총 6개가 배포됐는지 확인한다.</li>
</ol>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods
</code></pre></div></div>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-22-35.png" alt="" /></p>

<p><br /></p>

<ol>
  <li>인그레스와 마찬가지로 사전에 정의된 오브젝트 스펙으로 MetalLB를 구성한다. 이렇게 하면 MetalLB에 필요한 요소가 모두 설치되고 독립적인 <strong>네임스페이스(metallb-system)</strong>도 함께 만들어진다.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> ~/_Book_k8sInfra/ch3/3.3.4/metallb.yaml
</code></pre></div></div>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-24-17.png" alt="" /></p>

<p><br /></p>

<ol>
  <li>배포된 MetalLB의 파드가 5개(controller 1개, speaker 4개)인지 확인하고, IP와 상태도 확인한다. 스피커는 각 노드마다 설치가 된다. 컨트롤러 같은 경우는 한 개가 설치되는데 여기 있는 기능들을 관리해주는 기능을 한다. 즉 MetalLB와 관련된 파드들을 deploy했다. 이제 여기에 MetalLB가 L2 통신을 할 수 있도록 거기에 있는 IP라던가 세팅 값을 넣어주는 것들을 배포하도록 하겠다.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">-n</span> metallb-system <span class="nt">-o</span> wide
</code></pre></div></div>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-26-32.png" alt="" /></p>

<p><br /></p>

<ol>
  <li>인그레스와 마찬가지로 MetalLB도 설정을 적용해야 하는데, 다음 방법으로 적용한다. 이때 오브젝트는 ConfigMap을 사용한다. <strong>ConfigMap</strong>은 설정이 정의된 포맷이라고 생각하면 된다.</li>
</ol>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-25-59.png" alt="" /></p>

<p><br /></p>

<p>파일의 구성을 보자</p>

<p><strong>metallb-l2config.yaml</strong></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">metallb-system</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">config</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">config</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">address-pools:</span>
    <span class="s">- name: nginx-ip-range</span>
      <span class="s">protocol: layer2</span>
      <span class="s">addresses:</span>
      <span class="s">- 192.168.1.11-192.168.1.13</span>
</code></pre></div></div>

<p><br /></p>

<p>하나 하나 살펴보자</p>

<p><strong>metallb-l2config.yaml</strong></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#apiVersion: API 버전을 명시한다</span>
<span class="c1">#이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지</span>
<span class="c1">#명시한다.</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>

<span class="c1">#어떤 종류의 오브젝트를 생성하고자 하는지 명시한다.</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>

<span class="c1">#이름 문자열, UID, 그리고 선택적인 네임스페이스를 포함하여</span>
<span class="c1">#오브젝트를 유일하게 구분지어 줄 데이터이다.</span>
<span class="c1">#서비스 이름(name)은 config이다.</span>
<span class="na">metadata</span><span class="pi">:</span>

  <span class="c1">#ConfigMap이 위치하는 네임스페이스를</span>
  <span class="c1">#metallb-system로 한다.</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">metallb-system</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">config</span>

<span class="na">data</span><span class="pi">:</span>
  <span class="na">config</span><span class="pi">:</span> <span class="pi">|</span>

  <span class="s">#metallb의 세부 설정</span>
    <span class="s">address-pools:</span>
    <span class="s">- name: nginx-ip-range</span>

    <span class="s">#metallb에서 제공하는 로드밸런서의 동작 방식이다. 즉 L2 방식이다.</span>
      <span class="s">protocol: layer2</span>

      <span class="s">#metallb에서 제공하는 로드밸러서의 External 주소이다.</span>
      <span class="s">#이 범위 안에서 External 주소를 부여한다.</span>
      <span class="s">addresses:</span>
      <span class="s">- 192.168.1.11-192.168.1.13</span>
</code></pre></div></div>

<p><br /></p>

<ol>
  <li>ConfigMap이 생성됐는지 kubectl get configmap -n metallb-system 명령으로 확인한다.</li>
</ol>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get configmap <span class="nt">-n</span> metallb-system
</code></pre></div></div>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-33-20.png" alt="" /></p>

<p><br /></p>

<ol>
  <li><strong>-o yaml</strong> 옵션을 주고 다시 실행해 MetalLB의 설정이 올바르게 적용됐는지 확인한다.</li>
</ol>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get configmap <span class="nt">-n</span> metallb-system <span class="nt">-o</span> yaml
</code></pre></div></div>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-34-33.png" alt="" /></p>

<p><br /></p>

<ol>
  <li>모든 설정이 완료됐으니 이제 각 디플로이먼트(lb-hname-pods, lb-ip-pods)를 로드밸런서 서비스로 노출한다.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl expose deployment lb-hname-pods <span class="nt">--type</span><span class="o">=</span>LoadBalancer <span class="nt">--name</span><span class="o">=</span>lb-hname-svc <span class="nt">--port</span><span class="o">=</span>80

kubectl expose deployment lb-ip-pods <span class="nt">--type</span><span class="o">=</span>LoadBalancer <span class="nt">--name</span><span class="o">=</span>lb-ip-svc <span class="nt">--port</span><span class="o">=</span>80
</code></pre></div></div>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-36-21.png" alt="" /></p>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-38-11.png" alt="" /></p>

<p><br /></p>

<ol>
  <li>생성된 로드밸런서 서비스별로 CLUSTER-IP와 EXTERNAL-IP가 잘 적용됐는지 확인한다. 특히 EXTERNAL-IP에 ConfigMap을 통해 부여한 IP를 확인한다. 외부와 통신할 수 있는 EXTERNAL-IP가 부여된 것을 볼 수 있다.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get services
</code></pre></div></div>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-40-24.png" alt="" /></p>

<p><br /></p>

<ol>
  <li>EXTERNAL-IP가 잘 작동하는지도 확인해 본다. 호스트 노트북(또는 PC)에서 브라우저를 띄우고 192.168.1.11로 접속한다. 배포된 파드 중 하나의 이름이 브라우저에 표시되는지 확인한다.</li>
</ol>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-41-46.png" alt="" /></p>

<p><br /></p>

<ol>
  <li>192.168.1.12를 접속해 파드에 요청 방법과 IP가 표시되는지 확인한다.</li>
</ol>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-13-43-22.png" alt="" /></p>

<p><br /></p>

<p>삭제 작업</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete deployment lb-hname-pods

kubectl delete deployment lb-ip-pods

kubectl delete service lb-hname-svc

kubectl delete service lb-ip-svc
</code></pre></div></div>

<p><br /></p>

<link href="http://fonts.googleapis.com/earlyaccess/hanna.css" rel="stylesheet" />

<div style="background: #eee;
  box-shadow: 0 8px 8px -4px lightblue; font-family: 'Hanna', sans-serif;; padding: 40px;">

<span style="color:#85144b; font-weight:bold">부가설명</span>: 실제로 현재에 있는 시스템은 아래 사진에서 이 **INTERNAL-IP**를 가지고 있는데 이 IP가 외부에 노출되는 IP 성격이다. 왜냐면 현재 시스템들은 각각의 서버들이 가지고 있는 외부와 통신하는 IP를 가지고 쿠버네티스 클러스터 외부에 있는 것과 통신하기 때문에 실제적으로 이 **INTERNAL-IP**가 쿠버네티스 외부 딴에서 노출되는 IP라고 보는 게 좋다 지금은 VM 단에서 하고 있기 때문이다(온프레미스). 우리가 **metallb-l2config.yaml**에서 설정해줬던 **192.168.1.11-192.168.1.13** 이 범위가 외부의 노출되는 IP range로 잡아주는 것이다. 이게 약간 private network ip 같이 생겨서 부가설명을 하였다.</div>

<p><br /></p>

<p>기존의 노드포트에서 사용했을 때 인터넷 브라우저로 접근하려면 ip와 노드포트를 적어줘야 했었는데 만약에 해당 노드가 죽게 된다면 이 ip로 접근을 할 수 없었다. 그래서 실질적으로 expose하는 의미가 떨어지게 되는데 metallb를 사용하면 모든 노드에 걸쳐서 데몬셋이 생성이 되고 그 데몬셋이 리턴을 해주기 때문에 <strong>EXTERNAL IP</strong> 하나로 전체에 있는 클러스터의 대표 IP, 즉 VIP 성격으로 쓸 수 있는 것이다.</p>

<p><br /></p>

<p>또 이런 생각을 해볼 수 있다.</p>

<p>VIP, 즉 지금 EXTERNAl 되는 IP가 <strong>192.168.11-192.168.1.13</strong>까지 있었는데 만약 추가로 요구사항이 있어서 VIP를 추가로 생성하는 부분에 대해서는 어떻게 할까? 이것은 걱정할 필요는 없다. 우리가 추가로 서비스를 expose하면 된다. 만약에 VIP를 새로 생성한다는 의미는 다른 종류의 deployment를 붙인다는 것이 된다. 아래 사진과 같이 새로 생성한 디플로이먼트를 expose한 경우에 우리가 잡아놓은 IP range에서 부여되는 것을 볼 수 있다.</p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-17-54-13.png" alt="" /></p>

<p><br /></p>

<p><img src="/images/Kubernetes/kubernetes-Ingress/2021-08-01-17-54-52.png" alt="" /></p>

<p><br /></p>

<div style="background: #eee;
  box-shadow: 0 8px 8px -4px lightblue; font-family: 'Hanna', sans-serif;; padding: 40px;">

<span style="color:#85144b; font-weight:bold">추가설명</span>: MetalLB는 우리가 앞에서 비교해봤듯이 설치가 간단하고 ConfigMap를 조금만 구성하면 바로 쓸 수 있는 것을 확인했다. 그리고 노드포트와 다르게 노드는 노드가 죽는 경우에는 서비스하기 어렵다. 사용자에게 알려줘야 한다. 하지만 MetalLB는 대표 Ip 즉 VIP 성격을 가지기 때문에 IP를 우리가 설정한 대로만 계속 가져갈 수 있는 것을 확인했다. 그리고 우리가 추가로 Deployment 할 게 있다면 거기에 자동으로 CIDR 개념으로 IP가 자동으로 할동하는 것을 봤다. 굉장히 효율적으로 동작하게 온프레미스를 만들어주는 것을 볼 수 있다. </div>

<p><br /></p>

<div style="background: #eee;
  box-shadow: 0 8px 8px -4px lightblue; font-family: 'Hanna', sans-serif;; padding: 40px;">

<span style="color:#85144b; font-weight:bold">결론</span>: MetalLB같은 경우 지금 쭉 설명을 들었다시피 굉장히 간편하고 바로 쓸 수 있는 온프레미스 로드 밸런서 인다. </div>
:ET